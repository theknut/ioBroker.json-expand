{
  "version": 3,
  "sources": ["../../src/lib/json2iob.ts"],
  "sourcesContent": ["/* Copyright by https://github.com/TA2k/json2iob */\r\n\r\nimport JSONbig from \"json-bigint\";\r\n\r\ntype Options = {\r\n    write?: boolean; // Activate write for all states.\r\n    forceIndex?: boolean; // Instead of trying to find names for array entries, use the index as the name.\r\n    padArrayIndex?: boolean; // pad index numbers with 0, e.g. 01, 02, 03, ...\r\n    zeroBasedArrayIndex?: boolean; // Start array index from 0\r\n    channelName?: string; // Set name of the root channel.\r\n    preferedArrayName?: string; // Set key to use this as an array entry name.\r\n    preferedArrayDesc?: string;\r\n    autoCast?: boolean;\r\n    descriptions?: any;\r\n    states?: any;\r\n    units?: any;\r\n    parseBase64?: boolean;\r\n    parseBase64byIds?: string[];\r\n    deleteBeforeUpdate?: boolean;\r\n    removePasswords?: boolean;\r\n    excludeStateWithEnding?: string[];\r\n    makeStateWritableWithEnding?: string[];\r\n    dontSaveCreatedObjects?: boolean;\r\n};\r\ntype iobCommon = {\r\n    name?: string;\r\n    role: string;\r\n    type: string;\r\n    write: boolean | undefined;\r\n    read: boolean;\r\n    states?: any;\r\n    unit?: string;\r\n};\r\n\r\nclass Json2iob {\r\n    private adapter: any;\r\n    private alreadyCreatedObjects: any;\r\n    private objectTypes: any;\r\n    private forbiddenCharsRegex: RegExp;\r\n\r\n    constructor(adapter: any) {\r\n        if (!adapter) {\r\n            throw new Error(\"ioBroker Adapter is not defined!\");\r\n        }\r\n        this.adapter = adapter;\r\n        this.alreadyCreatedObjects = {};\r\n        this.objectTypes = {};\r\n        this.forbiddenCharsRegex = /[^._\\-/ :!#$%&()+=@^{}|~\\p{Ll}\\p{Lu}\\p{Nd}]+/gu;\r\n        if (this.adapter && this.adapter.FORBIDDEN_CHARS) {\r\n            this.forbiddenCharsRegex = this.adapter.FORBIDDEN_CHARS;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses the given element and creates states in the adapter based on the element's structure.\r\n     * @method parse\r\n     * @param {string} path - The ioBroker object path which the element should be saved to.\r\n     * @param {any} element - The element to be parsed.\r\n     * @param {Options} [options={}] - The parsing options.\r\n     * @param {boolean} [options.write] - Activate write for all states.\r\n     * @param {boolean} [options.forceIndex] - Instead of trying to find names for array entries, use the index as the name.\r\n     * @param {boolean} [options.padArrayIndex] - pad index numbers with 0, e.g. 01, 02, 03, ...\r\n     * @param {boolean} [options.zeroBasedArrayIndex] - Start array index from 0\r\n     * @param {string} [options.channelName] - Set name of the root channel.\r\n     * @param {string} [options.preferedArrayName] - Set key to use this as an array entry name.\r\n     * @param {string} [options.preferedArrayDesc] - Set key to use this as an array entry description.\r\n     * @param {boolean} [options.autoCast] - Make JSON.parse to parse numbers correctly.\r\n     * @param {Object} [options.descriptions] - Object of names for state keys.\r\n     * @param {Object} [options.states] - Object of states to create for an id, new entries via json will be added automatically to the states.\r\n     * @param {Object} [options.units] - Object of untis to create for an id\r\n     * @param {boolean} [options.parseBase64] - Parse base64 encoded strings to utf8.\r\n     * @param {string[]} [options.parseBase64byIds] - Array of ids to parse base64 encoded strings to utf8.\r\n     * @param {boolean} [options.deleteBeforeUpdate] - Delete channel before update.\r\n     * @param {boolean} [options.removePasswords] - Remove password from log.\r\n     * @param {string[]} [options.excludeStateWithEnding] - Array of strings to exclude states with this ending.\r\n     * @param {string[]} [options.makeStateWritableWithEnding] - Array of strings to make states with this ending writable.\r\n     * @param {boolean} [options.dontSaveCreatedObjects] - Create objects but do not save them to alreadyCreatedObjects.\r\n     * @returns {Promise<void>} - A promise that resolves when the parsing is complete.\r\n     */\r\n\r\n    async parse(path: string, element: any, options: Options = { write: false }): Promise<void> {\r\n        try {\r\n            if (element === null || element === undefined) {\r\n                this.adapter.log.debug(\"Cannot extract empty: \" + path);\r\n                return;\r\n            }\r\n\r\n            if (\r\n                (options.parseBase64 && this._isBase64(element)) ||\r\n                (options.parseBase64byIds && options.parseBase64byIds.includes(path))\r\n            ) {\r\n                try {\r\n                    element = Buffer.from(element, \"base64\").toString(\"utf8\");\r\n                    if (this._isJsonString(element)) {\r\n                        element = JSONbig.parse(element);\r\n                    }\r\n                } catch (error) {\r\n                    this.adapter.log.warn(`Cannot parse base64 for ${path}: ${error}`);\r\n                }\r\n            }\r\n            const objectKeys = Object.keys(element);\r\n\r\n            if (!options || !options.write) {\r\n                if (!options) {\r\n                    options = { write: false };\r\n                } else {\r\n                    options[\"write\"] = false;\r\n                }\r\n            }\r\n\r\n            path = path.toString().replace(this.forbiddenCharsRegex, \"_\");\r\n\r\n            if (typeof element === \"string\" || typeof element === \"number\") {\r\n                //remove ending . from path\r\n                if (path.endsWith(\".\")) {\r\n                    path = path.slice(0, -1);\r\n                }\r\n\r\n                const lastPathElement = path.split(\".\").pop();\r\n                if (options.excludeStateWithEnding && lastPathElement) {\r\n                    for (const excludeEnding of options.excludeStateWithEnding) {\r\n                        if (lastPathElement.endsWith(excludeEnding)) {\r\n                            this.adapter.log.debug(`skip state with ending : ${path}`);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                if (options.makeStateWritableWithEnding && lastPathElement) {\r\n                    for (const writingEnding of options.makeStateWritableWithEnding) {\r\n                        if (lastPathElement.toLowerCase().endsWith(writingEnding)) {\r\n                            this.adapter.log.debug(`make state with ending writable : ${path}`);\r\n                            options.write = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (!this.alreadyCreatedObjects[path] || this.objectTypes[path] !== typeof element) {\r\n                    let type = element !== null ? typeof element : \"mixed\";\r\n                    if (this.objectTypes[path] && this.objectTypes[path] !== typeof element) {\r\n                        type = \"mixed\";\r\n                        this.adapter.log.debug(`Type changed for ${path} from ${this.objectTypes[path]} to ${type}`);\r\n                    }\r\n                    let states;\r\n                    if (options.states && options.states[path]) {\r\n                        states = options.states[path];\r\n                        if (!states[element]) {\r\n                            states[element] = element;\r\n                        }\r\n                    }\r\n\r\n                    const common: iobCommon = {\r\n                        name: lastPathElement,\r\n                        role: this._getRole(element, options.write || false),\r\n                        type: type,\r\n                        write: options.write,\r\n                        read: true,\r\n                        states: states,\r\n                    };\r\n                    if (options.units && options.units[path]) {\r\n                        common.unit = options.units[path];\r\n                    }\r\n                    await this._createState(path, common, options);\r\n                }\r\n                await this.adapter.setStateAsync(path, element, true);\r\n\r\n                return;\r\n            }\r\n            if (options.removePasswords && path.toString().toLowerCase().includes(\"password\")) {\r\n                this.adapter.log.debug(`skip password : ${path}`);\r\n                return;\r\n            }\r\n            if (!this.alreadyCreatedObjects[path] || options.deleteBeforeUpdate) {\r\n                if (options.excludeStateWithEnding) {\r\n                    for (const excludeEnding of options.excludeStateWithEnding) {\r\n                        if (path.endsWith(excludeEnding)) {\r\n                            this.adapter.log.debug(`skip state with ending : ${path}`);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                if (options.makeStateWritableWithEnding) {\r\n                    for (const writingEnding of options.makeStateWritableWithEnding) {\r\n                        if (path.toLowerCase().endsWith(writingEnding)) {\r\n                            this.adapter.log.debug(`make state with ending writable : ${path}`);\r\n                            options.write = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (options.deleteBeforeUpdate) {\r\n                    this.adapter.log.debug(`Deleting ${path} before update`);\r\n                    for (const key in this.alreadyCreatedObjects) {\r\n                        if (key.startsWith(path)) {\r\n                            delete this.alreadyCreatedObjects[key];\r\n                        }\r\n                    }\r\n                    await this.adapter.delObjectAsync(path, { recursive: true });\r\n                }\r\n                let name = options.channelName || \"\";\r\n                if (options.preferedArrayDesc && element[options.preferedArrayDesc]) {\r\n                    name = element[options.preferedArrayDesc];\r\n                }\r\n                await this.adapter\r\n                    .setObjectNotExistsAsync(path, {\r\n                        type: \"channel\",\r\n                        common: {\r\n                            name: name,\r\n                            write: false,\r\n                            read: true,\r\n                        },\r\n                        native: {},\r\n                    })\r\n                    .then(() => {\r\n                        if (!options.dontSaveCreatedObjects) {\r\n                            this.alreadyCreatedObjects[path] = true;\r\n                        }\r\n                        options.channelName = undefined;\r\n                        options.deleteBeforeUpdate = undefined;\r\n                    })\r\n                    .catch((error: any) => {\r\n                        this.adapter.log.error(error);\r\n                    });\r\n            }\r\n            if (Array.isArray(element)) {\r\n                await this._extractArray(element, \"\", path, options);\r\n                return;\r\n            }\r\n\r\n            for (const key of objectKeys) {\r\n                if (key.toLowerCase().includes(\"password\") && options.removePasswords) {\r\n                    this.adapter.log.debug(`skip password : ${path}.${key}`);\r\n                    return;\r\n                }\r\n                if (typeof element[key] === \"function\") {\r\n                    this.adapter.log.debug(\"Skip function: \" + path + \".\" + key);\r\n                    continue;\r\n                }\r\n                if (element[key] == null) {\r\n                    element[key] = \"\";\r\n                }\r\n                if (this._isJsonString(element[key]) && options.autoCast) {\r\n                    element[key] = JSONbig.parse(element[key]);\r\n                }\r\n\r\n                if (\r\n                    (options.parseBase64 && this._isBase64(element[key])) ||\r\n                    (options.parseBase64byIds && options.parseBase64byIds.includes(key))\r\n                ) {\r\n                    try {\r\n                        element[key] = Buffer.from(element[key], \"base64\").toString(\"utf8\");\r\n                        if (this._isJsonString(element[key])) {\r\n                            element[key] = JSONbig.parse(element[key]);\r\n                        }\r\n                    } catch (error) {\r\n                        this.adapter.log.warn(`Cannot parse base64 for ${path + \".\" + key}: ${error}`);\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(element[key])) {\r\n                    await this._extractArray(element, key, path, options);\r\n                } else if (element[key] !== null && typeof element[key] === \"object\") {\r\n                    await this.parse(path + \".\" + key, element[key], options);\r\n                } else {\r\n                    const pathKey = key.replace(/\\./g, \"_\");\r\n                    if (\r\n                        !this.alreadyCreatedObjects[path + \".\" + pathKey] ||\r\n                        this.objectTypes[path + \".\" + pathKey] !== typeof element[key]\r\n                    ) {\r\n                        let objectName = key;\r\n                        if (options.descriptions && options.descriptions[key]) {\r\n                            objectName = options.descriptions[key];\r\n                        }\r\n                        let type = element[key] !== null ? typeof element[key] : \"mixed\";\r\n                        if (\r\n                            this.objectTypes[path + \".\" + pathKey] &&\r\n                            this.objectTypes[path + \".\" + pathKey] !== typeof element[key]\r\n                        ) {\r\n                            type = \"mixed\";\r\n                            this.adapter.log.debug(\r\n                                `Type changed for ${path + \".\" + pathKey} from ${\r\n                                    this.objectTypes[path + \".\" + pathKey]\r\n                                } to ${type}`,\r\n                            );\r\n                        }\r\n                        let states;\r\n                        if (options.states && options.states[key]) {\r\n                            states = options.states[key];\r\n                            if (!states[element[key]]) {\r\n                                states[element[key]] = element[key];\r\n                            }\r\n                        }\r\n\r\n                        const common: iobCommon = {\r\n                            name: objectName,\r\n                            role: this._getRole(element[key], options.write || false),\r\n                            type: type,\r\n                            write: options.write,\r\n                            read: true,\r\n                            states: states,\r\n                        };\r\n\r\n                        if (options.units && options.units[key]) {\r\n                            common.unit = options.units[key]; // Assign the value to the 'unit' property\r\n                        }\r\n                        await this._createState(path + \".\" + pathKey, common, options);\r\n                    }\r\n                    await this.adapter.setStateAsync(path + \".\" + pathKey, element[key], true);\r\n                }\r\n            }\r\n        } catch (error) {\r\n            this.adapter.log.error(\"Error extract keys: \" + path + \" \" + JSON.stringify(element));\r\n            this.adapter.log.error(error);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a state object in the adapter's namespace.\r\n     * @param {string} path - The path of the state object.\r\n     * @param {object} common - The common object for the state.\r\n     * @param {object} [options] - Optional parameters.\r\n     * @param {boolean} [options.dontSaveCreatedObjects] - If true, the created object will not be saved.\r\n     * @returns {Promise<void>} - A promise that resolves when the state object is created.\r\n     */\r\n    async _createState(path: string, common: any, options: Options = {}): Promise<void> {\r\n        await this.adapter\r\n            .extendObjectAsync(path, {\r\n                type: \"state\",\r\n                common: common,\r\n                native: {},\r\n            })\r\n            .then(() => {\r\n                if (!options.dontSaveCreatedObjects) {\r\n                    this.alreadyCreatedObjects[path] = true;\r\n                }\r\n                this.objectTypes[path] = common.type;\r\n            })\r\n            .catch((error: any) => {\r\n                this.adapter.log.error(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Extracts an array from the given element and recursively parses its elements.\r\n     *\r\n     * @param {object} element - The element containing the array.\r\n     * @param {string} key - The key of the array in the element.\r\n     * @param {string} path - The current path in the object hierarchy.\r\n     * @param {object} options - The parsing options.\r\n     * @returns {Promise<void>} - A promise that resolves when the array extraction and parsing is complete.\r\n     */\r\n    async _extractArray(element: any, key: string, path: string, options: Options): Promise<void> {\r\n        try {\r\n            if (key) {\r\n                element = element[key];\r\n            }\r\n            for (let index in element) {\r\n                let arrayElement = element[index];\r\n                if (arrayElement == null) {\r\n                    this.adapter.log.debug(\"Cannot extract empty: \" + path + \".\" + key + \".\" + index);\r\n                    continue;\r\n                }\r\n\r\n                let indexNumber = parseInt(index) + 1;\r\n                index = indexNumber.toString();\r\n\r\n                if (indexNumber < 10) {\r\n                    index = \"0\" + index;\r\n                }\r\n                if (options.autoCast && typeof arrayElement === \"string\" && this._isJsonString(arrayElement)) {\r\n                    try {\r\n                        element[index] = JSONbig.parse(arrayElement);\r\n                        arrayElement = element[index];\r\n                    } catch (error) {\r\n                        this.adapter.log.warn(\r\n                            `Cannot parse json value for ${path + \".\" + key + \".\" + index}: ${error}`,\r\n                        );\r\n                    }\r\n                }\r\n                let arrayPath = key + index;\r\n                if (typeof arrayElement === \"string\" && key !== \"\") {\r\n                    await this.parse(path + \".\" + key + \".\" + arrayElement, arrayElement, options);\r\n                    continue;\r\n                }\r\n                if (typeof arrayElement[Object.keys(arrayElement)[0]] === \"string\") {\r\n                    arrayPath = arrayElement[Object.keys(arrayElement)[0]];\r\n                }\r\n                for (const keyName of Object.keys(arrayElement)) {\r\n                    if (keyName.endsWith(\"Id\") && arrayElement[keyName] !== null) {\r\n                        if (arrayElement[keyName] && arrayElement[keyName].replace) {\r\n                            arrayPath = arrayElement[keyName].replace(/\\./g, \"\");\r\n                        } else {\r\n                            arrayPath = arrayElement[keyName];\r\n                        }\r\n                    }\r\n                }\r\n                for (const keyName in Object.keys(arrayElement)) {\r\n                    if (keyName.endsWith(\"Name\")) {\r\n                        if (arrayElement[keyName] && arrayElement[keyName].replace) {\r\n                            arrayPath = arrayElement[keyName].replace(/\\./g, \"\");\r\n                        } else {\r\n                            arrayPath = arrayElement[keyName];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (arrayElement.id) {\r\n                    if (arrayElement.id.replace) {\r\n                        arrayPath = arrayElement.id.replace(/\\./g, \"\");\r\n                    } else {\r\n                        arrayPath = arrayElement.id;\r\n                    }\r\n                }\r\n                if (arrayElement.name) {\r\n                    arrayPath = arrayElement.name.replace(/\\./g, \"\");\r\n                }\r\n                if (arrayElement.label) {\r\n                    arrayPath = arrayElement.label.replace(/\\./g, \"\");\r\n                }\r\n                if (arrayElement.labelText) {\r\n                    arrayPath = arrayElement.labelText.replace(/\\./g, \"\");\r\n                }\r\n                if (arrayElement.start_date_time) {\r\n                    arrayPath = arrayElement.start_date_time.replace(/\\./g, \"\");\r\n                }\r\n\r\n                if (options.preferedArrayName && options.preferedArrayName.indexOf(\"+\") !== -1) {\r\n                    const preferedArrayNameArray = options.preferedArrayName.split(\"+\");\r\n                    if (arrayElement[preferedArrayNameArray[0]] !== undefined) {\r\n                        const element0 = arrayElement[preferedArrayNameArray[0]]\r\n                            .toString()\r\n                            .replace(/\\./g, \"\")\r\n                            .replace(/ /g, \"\");\r\n                        let element1 = \"\";\r\n                        if (preferedArrayNameArray[1].indexOf(\"/\") !== -1) {\r\n                            const subArray = preferedArrayNameArray[1].split(\"/\");\r\n                            const subElement = arrayElement[subArray[0]];\r\n                            if (subElement && subElement[subArray[1]] !== undefined) {\r\n                                element1 = subElement[subArray[1]];\r\n                            } else if (arrayElement[subArray[1]] !== undefined) {\r\n                                element1 = arrayElement[subArray[1]];\r\n                            }\r\n                        } else {\r\n                            element1 = arrayElement[preferedArrayNameArray[1]]\r\n                                .toString()\r\n                                .replace(/\\./g, \"\")\r\n                                .replace(/ /g, \"\");\r\n                        }\r\n                        arrayPath = element0 + \"-\" + element1;\r\n                    }\r\n                } else if (options.preferedArrayName && options.preferedArrayName.indexOf(\"/\") !== -1) {\r\n                    const preferedArrayNameArray = options.preferedArrayName.split(\"/\");\r\n                    const subElement = arrayElement[preferedArrayNameArray[0]];\r\n                    if (subElement) {\r\n                        arrayPath = subElement[preferedArrayNameArray[1]]\r\n                            .toString()\r\n                            .replace(/\\./g, \"\")\r\n                            .replace(/ /g, \"\");\r\n                    }\r\n                } else if (options.preferedArrayName && arrayElement[options.preferedArrayName]) {\r\n                    arrayPath = arrayElement[options.preferedArrayName].toString().replace(/\\./g, \"\");\r\n                }\r\n\r\n                if (options.forceIndex) {\r\n                    if (options.zeroBasedArrayIndex === true) {\r\n                        indexNumber -= 1;\r\n                    }\r\n\r\n                    index = `${options.padArrayIndex === true && indexNumber < 10 ? \"0\" : \"\"}${indexNumber}`;\r\n                    arrayPath = key + index;\r\n                }\r\n                //special case array with 2 string objects\r\n                if (\r\n                    !options.forceIndex &&\r\n                    Object.keys(arrayElement).length === 2 &&\r\n                    typeof Object.keys(arrayElement)[0] === \"string\" &&\r\n                    typeof Object.keys(arrayElement)[1] === \"string\" &&\r\n                    typeof arrayElement[Object.keys(arrayElement)[0]] !== \"object\" &&\r\n                    typeof arrayElement[Object.keys(arrayElement)[1]] !== \"object\" &&\r\n                    arrayElement[Object.keys(arrayElement)[0]] !== \"null\"\r\n                ) {\r\n                    let subKey = arrayElement[Object.keys(arrayElement)[0]];\r\n                    let subValue = arrayElement[Object.keys(arrayElement)[1]];\r\n\r\n                    if (\r\n                        (options.parseBase64 && this._isBase64(subValue)) ||\r\n                        (options.parseBase64byIds && options.parseBase64byIds.includes(subKey))\r\n                    ) {\r\n                        try {\r\n                            subValue = Buffer.from(subValue, \"base64\").toString(\"utf8\");\r\n                            if (this._isJsonString(subValue)) {\r\n                                subValue = JSONbig.parse(subValue);\r\n                            }\r\n                        } catch (error) {\r\n                            this.adapter.log.warn(\r\n                                `Cannot parse base64 value ${subValue} for ${path + \".\" + subKey}: ${error}`,\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    const subName = Object.keys(arrayElement)[0] + \" \" + Object.keys(arrayElement)[1];\r\n                    if (key) {\r\n                        subKey = key + \".\" + subKey;\r\n                    }\r\n                    if (\r\n                        !this.alreadyCreatedObjects[path + \".\" + subKey] ||\r\n                        this.objectTypes[path + \".\" + subKey] !== typeof subValue\r\n                    ) {\r\n                        let type = subValue !== null ? typeof subValue : \"mixed\";\r\n                        if (\r\n                            this.objectTypes[path + \".\" + subKey] &&\r\n                            this.objectTypes[path + \".\" + subKey] !== typeof subValue\r\n                        ) {\r\n                            this.adapter.log.debug(\r\n                                `Type of ${path + \".\" + subKey} changed from ${\r\n                                    this.objectTypes[path + \".\" + subKey]\r\n                                } to ${typeof subValue}!`,\r\n                            );\r\n                            type = \"mixed\";\r\n                        }\r\n                        let states;\r\n                        if (options.states && options.states[subKey]) {\r\n                            states = options.states[subKey];\r\n                            if (!states[subValue]) {\r\n                                states[subValue] = subValue;\r\n                            }\r\n                        }\r\n                        const common: iobCommon = {\r\n                            name: subName,\r\n                            role: this._getRole(subValue, options.write || false),\r\n                            type: type,\r\n                            write: options.write,\r\n                            read: true,\r\n                            states: states,\r\n                        };\r\n                        if (options.units && options.units[subKey]) {\r\n                            common.unit = options.units[subKey];\r\n                        }\r\n                        await this._createState(path + \".\" + subKey, common, options);\r\n                    }\r\n                    await this.adapter.setStateAsync(path + \".\" + subKey, subValue, true);\r\n                    continue;\r\n                }\r\n                await this.parse(path + \".\" + arrayPath, arrayElement, options);\r\n            }\r\n        } catch (error) {\r\n            this.adapter.log.error(\"Cannot extract array \" + path);\r\n            this.adapter.log.error(error);\r\n        }\r\n    }\r\n    /**\r\n     * Checks if a string is a valid base64 encoded string.\r\n     *\r\n     * @param {string} str - The string to be checked.\r\n     * @returns {boolean} - Returns true if the string is a valid base64 encoded string, otherwise returns false.\r\n     */\r\n    _isBase64(str: string): boolean {\r\n        if (!str || typeof str !== \"string\") {\r\n            return false;\r\n        }\r\n        const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))/;\r\n        return base64regex.test(str);\r\n    }\r\n\r\n    /**\r\n     * Checks if a given string is a valid JSON string.\r\n     * @param {string} str - The string to be checked.\r\n     * @returns {boolean} - Returns true if the string is a valid JSON string, otherwise false.\r\n     */\r\n    _isJsonString(str: string): boolean {\r\n        try {\r\n            JSON.parse(str);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Determines the role of an element based on its type and write mode.\r\n     * @param {any} element - The element to determine the role for.\r\n     * @param {boolean} write - Indicates whether the element is being written to.\r\n     * @returns {string} - The role of the element.\r\n     */\r\n    _getRole(element: any, write: boolean): string {\r\n        if (typeof element === \"boolean\" && !write) {\r\n            return \"indicator\";\r\n        }\r\n        if (typeof element === \"boolean\" && write) {\r\n            return \"switch\";\r\n        }\r\n        if (typeof element === \"number\" && !write) {\r\n            if (element && element.toString().length === 13) {\r\n                if (element > 1500000000000 && element < 2000000000000) {\r\n                    return \"value.time\";\r\n                }\r\n            }\r\n            return \"value\";\r\n        }\r\n        if (typeof element === \"number\" && write) {\r\n            return \"level\";\r\n        }\r\n        if (typeof element === \"string\") {\r\n            return \"text\";\r\n        }\r\n        return \"state\";\r\n    }\r\n}\r\nexport = Json2iob;\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAEA,yBAAoB;AAgCpB,MAAM,SAAS;AAAA,EAMX,YAAY,SAAc;AACtB,QAAI,CAAC,SAAS;AACV,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACtD;AACA,SAAK,UAAU;AACf,SAAK,wBAAwB,CAAC;AAC9B,SAAK,cAAc,CAAC;AACpB,SAAK,sBAAsB;AAC3B,QAAI,KAAK,WAAW,KAAK,QAAQ,iBAAiB;AAC9C,WAAK,sBAAsB,KAAK,QAAQ;AAAA,IAC5C;AAAA,EACJ;AAAA,EA6BA,MAAM,MAAM,MAAc,SAAc,UAAmB,EAAE,OAAO,MAAM,GAAkB;AACxF,QAAI;AACA,UAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,aAAK,QAAQ,IAAI,MAAM,2BAA2B,IAAI;AACtD;AAAA,MACJ;AAEA,UACK,QAAQ,eAAe,KAAK,UAAU,OAAO,KAC7C,QAAQ,oBAAoB,QAAQ,iBAAiB,SAAS,IAAI,GACrE;AACE,YAAI;AACA,oBAAU,OAAO,KAAK,SAAS,QAAQ,EAAE,SAAS,MAAM;AACxD,cAAI,KAAK,cAAc,OAAO,GAAG;AAC7B,sBAAU,mBAAAA,QAAQ,MAAM,OAAO;AAAA,UACnC;AAAA,QACJ,SAAS,OAAP;AACE,eAAK,QAAQ,IAAI,KAAK,2BAA2B,SAAS,OAAO;AAAA,QACrE;AAAA,MACJ;AACA,YAAM,aAAa,OAAO,KAAK,OAAO;AAEtC,UAAI,CAAC,WAAW,CAAC,QAAQ,OAAO;AAC5B,YAAI,CAAC,SAAS;AACV,oBAAU,EAAE,OAAO,MAAM;AAAA,QAC7B,OAAO;AACH,kBAAQ,WAAW;AAAA,QACvB;AAAA,MACJ;AAEA,aAAO,KAAK,SAAS,EAAE,QAAQ,KAAK,qBAAqB,GAAG;AAE5D,UAAI,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU;AAE5D,YAAI,KAAK,SAAS,GAAG,GAAG;AACpB,iBAAO,KAAK,MAAM,GAAG,EAAE;AAAA,QAC3B;AAEA,cAAM,kBAAkB,KAAK,MAAM,GAAG,EAAE,IAAI;AAC5C,YAAI,QAAQ,0BAA0B,iBAAiB;AACnD,qBAAW,iBAAiB,QAAQ,wBAAwB;AACxD,gBAAI,gBAAgB,SAAS,aAAa,GAAG;AACzC,mBAAK,QAAQ,IAAI,MAAM,4BAA4B,MAAM;AACzD;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,QAAQ,+BAA+B,iBAAiB;AACxD,qBAAW,iBAAiB,QAAQ,6BAA6B;AAC7D,gBAAI,gBAAgB,YAAY,EAAE,SAAS,aAAa,GAAG;AACvD,mBAAK,QAAQ,IAAI,MAAM,qCAAqC,MAAM;AAClE,sBAAQ,QAAQ;AAAA,YACpB;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,CAAC,KAAK,sBAAsB,SAAS,KAAK,YAAY,UAAU,OAAO,SAAS;AAChF,cAAI,OAAO,YAAY,OAAO,OAAO,UAAU;AAC/C,cAAI,KAAK,YAAY,SAAS,KAAK,YAAY,UAAU,OAAO,SAAS;AACrE,mBAAO;AACP,iBAAK,QAAQ,IAAI,MAAM,oBAAoB,aAAa,KAAK,YAAY,YAAY,MAAM;AAAA,UAC/F;AACA,cAAI;AACJ,cAAI,QAAQ,UAAU,QAAQ,OAAO,OAAO;AACxC,qBAAS,QAAQ,OAAO;AACxB,gBAAI,CAAC,OAAO,UAAU;AAClB,qBAAO,WAAW;AAAA,YACtB;AAAA,UACJ;AAEA,gBAAM,SAAoB;AAAA,YACtB,MAAM;AAAA,YACN,MAAM,KAAK,SAAS,SAAS,QAAQ,SAAS,KAAK;AAAA,YACnD;AAAA,YACA,OAAO,QAAQ;AAAA,YACf,MAAM;AAAA,YACN;AAAA,UACJ;AACA,cAAI,QAAQ,SAAS,QAAQ,MAAM,OAAO;AACtC,mBAAO,OAAO,QAAQ,MAAM;AAAA,UAChC;AACA,gBAAM,KAAK,aAAa,MAAM,QAAQ,OAAO;AAAA,QACjD;AACA,cAAM,KAAK,QAAQ,cAAc,MAAM,SAAS,IAAI;AAEpD;AAAA,MACJ;AACA,UAAI,QAAQ,mBAAmB,KAAK,SAAS,EAAE,YAAY,EAAE,SAAS,UAAU,GAAG;AAC/E,aAAK,QAAQ,IAAI,MAAM,mBAAmB,MAAM;AAChD;AAAA,MACJ;AACA,UAAI,CAAC,KAAK,sBAAsB,SAAS,QAAQ,oBAAoB;AACjE,YAAI,QAAQ,wBAAwB;AAChC,qBAAW,iBAAiB,QAAQ,wBAAwB;AACxD,gBAAI,KAAK,SAAS,aAAa,GAAG;AAC9B,mBAAK,QAAQ,IAAI,MAAM,4BAA4B,MAAM;AACzD;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,QAAQ,6BAA6B;AACrC,qBAAW,iBAAiB,QAAQ,6BAA6B;AAC7D,gBAAI,KAAK,YAAY,EAAE,SAAS,aAAa,GAAG;AAC5C,mBAAK,QAAQ,IAAI,MAAM,qCAAqC,MAAM;AAClE,sBAAQ,QAAQ;AAAA,YACpB;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,QAAQ,oBAAoB;AAC5B,eAAK,QAAQ,IAAI,MAAM,YAAY,oBAAoB;AACvD,qBAAW,OAAO,KAAK,uBAAuB;AAC1C,gBAAI,IAAI,WAAW,IAAI,GAAG;AACtB,qBAAO,KAAK,sBAAsB;AAAA,YACtC;AAAA,UACJ;AACA,gBAAM,KAAK,QAAQ,eAAe,MAAM,EAAE,WAAW,KAAK,CAAC;AAAA,QAC/D;AACA,YAAI,OAAO,QAAQ,eAAe;AAClC,YAAI,QAAQ,qBAAqB,QAAQ,QAAQ,oBAAoB;AACjE,iBAAO,QAAQ,QAAQ;AAAA,QAC3B;AACA,cAAM,KAAK,QACN,wBAAwB,MAAM;AAAA,UAC3B,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ;AAAA,YACA,OAAO;AAAA,YACP,MAAM;AAAA,UACV;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC,EACA,KAAK,MAAM;AACR,cAAI,CAAC,QAAQ,wBAAwB;AACjC,iBAAK,sBAAsB,QAAQ;AAAA,UACvC;AACA,kBAAQ,cAAc;AACtB,kBAAQ,qBAAqB;AAAA,QACjC,CAAC,EACA,MAAM,CAAC,UAAe;AACnB,eAAK,QAAQ,IAAI,MAAM,KAAK;AAAA,QAChC,CAAC;AAAA,MACT;AACA,UAAI,MAAM,QAAQ,OAAO,GAAG;AACxB,cAAM,KAAK,cAAc,SAAS,IAAI,MAAM,OAAO;AACnD;AAAA,MACJ;AAEA,iBAAW,OAAO,YAAY;AAC1B,YAAI,IAAI,YAAY,EAAE,SAAS,UAAU,KAAK,QAAQ,iBAAiB;AACnE,eAAK,QAAQ,IAAI,MAAM,mBAAmB,QAAQ,KAAK;AACvD;AAAA,QACJ;AACA,YAAI,OAAO,QAAQ,SAAS,YAAY;AACpC,eAAK,QAAQ,IAAI,MAAM,oBAAoB,OAAO,MAAM,GAAG;AAC3D;AAAA,QACJ;AACA,YAAI,QAAQ,QAAQ,MAAM;AACtB,kBAAQ,OAAO;AAAA,QACnB;AACA,YAAI,KAAK,cAAc,QAAQ,IAAI,KAAK,QAAQ,UAAU;AACtD,kBAAQ,OAAO,mBAAAA,QAAQ,MAAM,QAAQ,IAAI;AAAA,QAC7C;AAEA,YACK,QAAQ,eAAe,KAAK,UAAU,QAAQ,IAAI,KAClD,QAAQ,oBAAoB,QAAQ,iBAAiB,SAAS,GAAG,GACpE;AACE,cAAI;AACA,oBAAQ,OAAO,OAAO,KAAK,QAAQ,MAAM,QAAQ,EAAE,SAAS,MAAM;AAClE,gBAAI,KAAK,cAAc,QAAQ,IAAI,GAAG;AAClC,sBAAQ,OAAO,mBAAAA,QAAQ,MAAM,QAAQ,IAAI;AAAA,YAC7C;AAAA,UACJ,SAAS,OAAP;AACE,iBAAK,QAAQ,IAAI,KAAK,2BAA2B,OAAO,MAAM,QAAQ,OAAO;AAAA,UACjF;AAAA,QACJ;AAEA,YAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC7B,gBAAM,KAAK,cAAc,SAAS,KAAK,MAAM,OAAO;AAAA,QACxD,WAAW,QAAQ,SAAS,QAAQ,OAAO,QAAQ,SAAS,UAAU;AAClE,gBAAM,KAAK,MAAM,OAAO,MAAM,KAAK,QAAQ,MAAM,OAAO;AAAA,QAC5D,OAAO;AACH,gBAAM,UAAU,IAAI,QAAQ,OAAO,GAAG;AACtC,cACI,CAAC,KAAK,sBAAsB,OAAO,MAAM,YACzC,KAAK,YAAY,OAAO,MAAM,aAAa,OAAO,QAAQ,MAC5D;AACE,gBAAI,aAAa;AACjB,gBAAI,QAAQ,gBAAgB,QAAQ,aAAa,MAAM;AACnD,2BAAa,QAAQ,aAAa;AAAA,YACtC;AACA,gBAAI,OAAO,QAAQ,SAAS,OAAO,OAAO,QAAQ,OAAO;AACzD,gBACI,KAAK,YAAY,OAAO,MAAM,YAC9B,KAAK,YAAY,OAAO,MAAM,aAAa,OAAO,QAAQ,MAC5D;AACE,qBAAO;AACP,mBAAK,QAAQ,IAAI;AAAA,gBACb,oBAAoB,OAAO,MAAM,gBAC7B,KAAK,YAAY,OAAO,MAAM,eAC3B;AAAA,cACX;AAAA,YACJ;AACA,gBAAI;AACJ,gBAAI,QAAQ,UAAU,QAAQ,OAAO,MAAM;AACvC,uBAAS,QAAQ,OAAO;AACxB,kBAAI,CAAC,OAAO,QAAQ,OAAO;AACvB,uBAAO,QAAQ,QAAQ,QAAQ;AAAA,cACnC;AAAA,YACJ;AAEA,kBAAM,SAAoB;AAAA,cACtB,MAAM;AAAA,cACN,MAAM,KAAK,SAAS,QAAQ,MAAM,QAAQ,SAAS,KAAK;AAAA,cACxD;AAAA,cACA,OAAO,QAAQ;AAAA,cACf,MAAM;AAAA,cACN;AAAA,YACJ;AAEA,gBAAI,QAAQ,SAAS,QAAQ,MAAM,MAAM;AACrC,qBAAO,OAAO,QAAQ,MAAM;AAAA,YAChC;AACA,kBAAM,KAAK,aAAa,OAAO,MAAM,SAAS,QAAQ,OAAO;AAAA,UACjE;AACA,gBAAM,KAAK,QAAQ,cAAc,OAAO,MAAM,SAAS,QAAQ,MAAM,IAAI;AAAA,QAC7E;AAAA,MACJ;AAAA,IACJ,SAAS,OAAP;AACE,WAAK,QAAQ,IAAI,MAAM,yBAAyB,OAAO,MAAM,KAAK,UAAU,OAAO,CAAC;AACpF,WAAK,QAAQ,IAAI,MAAM,KAAK;AAAA,IAChC;AAAA,EACJ;AAAA,EASA,MAAM,aAAa,MAAc,QAAa,UAAmB,CAAC,GAAkB;AAChF,UAAM,KAAK,QACN,kBAAkB,MAAM;AAAA,MACrB,MAAM;AAAA,MACN;AAAA,MACA,QAAQ,CAAC;AAAA,IACb,CAAC,EACA,KAAK,MAAM;AACR,UAAI,CAAC,QAAQ,wBAAwB;AACjC,aAAK,sBAAsB,QAAQ;AAAA,MACvC;AACA,WAAK,YAAY,QAAQ,OAAO;AAAA,IACpC,CAAC,EACA,MAAM,CAAC,UAAe;AACnB,WAAK,QAAQ,IAAI,MAAM,KAAK;AAAA,IAChC,CAAC;AAAA,EACT;AAAA,EAWA,MAAM,cAAc,SAAc,KAAa,MAAc,SAAiC;AAC1F,QAAI;AACA,UAAI,KAAK;AACL,kBAAU,QAAQ;AAAA,MACtB;AACA,eAAS,SAAS,SAAS;AACvB,YAAI,eAAe,QAAQ;AAC3B,YAAI,gBAAgB,MAAM;AACtB,eAAK,QAAQ,IAAI,MAAM,2BAA2B,OAAO,MAAM,MAAM,MAAM,KAAK;AAChF;AAAA,QACJ;AAEA,YAAI,cAAc,SAAS,KAAK,IAAI;AACpC,gBAAQ,YAAY,SAAS;AAE7B,YAAI,cAAc,IAAI;AAClB,kBAAQ,MAAM;AAAA,QAClB;AACA,YAAI,QAAQ,YAAY,OAAO,iBAAiB,YAAY,KAAK,cAAc,YAAY,GAAG;AAC1F,cAAI;AACA,oBAAQ,SAAS,mBAAAA,QAAQ,MAAM,YAAY;AAC3C,2BAAe,QAAQ;AAAA,UAC3B,SAAS,OAAP;AACE,iBAAK,QAAQ,IAAI;AAAA,cACb,+BAA+B,OAAO,MAAM,MAAM,MAAM,UAAU;AAAA,YACtE;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,YAAY,MAAM;AACtB,YAAI,OAAO,iBAAiB,YAAY,QAAQ,IAAI;AAChD,gBAAM,KAAK,MAAM,OAAO,MAAM,MAAM,MAAM,cAAc,cAAc,OAAO;AAC7E;AAAA,QACJ;AACA,YAAI,OAAO,aAAa,OAAO,KAAK,YAAY,EAAE,QAAQ,UAAU;AAChE,sBAAY,aAAa,OAAO,KAAK,YAAY,EAAE;AAAA,QACvD;AACA,mBAAW,WAAW,OAAO,KAAK,YAAY,GAAG;AAC7C,cAAI,QAAQ,SAAS,IAAI,KAAK,aAAa,aAAa,MAAM;AAC1D,gBAAI,aAAa,YAAY,aAAa,SAAS,SAAS;AACxD,0BAAY,aAAa,SAAS,QAAQ,OAAO,EAAE;AAAA,YACvD,OAAO;AACH,0BAAY,aAAa;AAAA,YAC7B;AAAA,UACJ;AAAA,QACJ;AACA,mBAAW,WAAW,OAAO,KAAK,YAAY,GAAG;AAC7C,cAAI,QAAQ,SAAS,MAAM,GAAG;AAC1B,gBAAI,aAAa,YAAY,aAAa,SAAS,SAAS;AACxD,0BAAY,aAAa,SAAS,QAAQ,OAAO,EAAE;AAAA,YACvD,OAAO;AACH,0BAAY,aAAa;AAAA,YAC7B;AAAA,UACJ;AAAA,QACJ;AAEA,YAAI,aAAa,IAAI;AACjB,cAAI,aAAa,GAAG,SAAS;AACzB,wBAAY,aAAa,GAAG,QAAQ,OAAO,EAAE;AAAA,UACjD,OAAO;AACH,wBAAY,aAAa;AAAA,UAC7B;AAAA,QACJ;AACA,YAAI,aAAa,MAAM;AACnB,sBAAY,aAAa,KAAK,QAAQ,OAAO,EAAE;AAAA,QACnD;AACA,YAAI,aAAa,OAAO;AACpB,sBAAY,aAAa,MAAM,QAAQ,OAAO,EAAE;AAAA,QACpD;AACA,YAAI,aAAa,WAAW;AACxB,sBAAY,aAAa,UAAU,QAAQ,OAAO,EAAE;AAAA,QACxD;AACA,YAAI,aAAa,iBAAiB;AAC9B,sBAAY,aAAa,gBAAgB,QAAQ,OAAO,EAAE;AAAA,QAC9D;AAEA,YAAI,QAAQ,qBAAqB,QAAQ,kBAAkB,QAAQ,GAAG,MAAM,IAAI;AAC5E,gBAAM,yBAAyB,QAAQ,kBAAkB,MAAM,GAAG;AAClE,cAAI,aAAa,uBAAuB,QAAQ,QAAW;AACvD,kBAAM,WAAW,aAAa,uBAAuB,IAChD,SAAS,EACT,QAAQ,OAAO,EAAE,EACjB,QAAQ,MAAM,EAAE;AACrB,gBAAI,WAAW;AACf,gBAAI,uBAAuB,GAAG,QAAQ,GAAG,MAAM,IAAI;AAC/C,oBAAM,WAAW,uBAAuB,GAAG,MAAM,GAAG;AACpD,oBAAM,aAAa,aAAa,SAAS;AACzC,kBAAI,cAAc,WAAW,SAAS,QAAQ,QAAW;AACrD,2BAAW,WAAW,SAAS;AAAA,cACnC,WAAW,aAAa,SAAS,QAAQ,QAAW;AAChD,2BAAW,aAAa,SAAS;AAAA,cACrC;AAAA,YACJ,OAAO;AACH,yBAAW,aAAa,uBAAuB,IAC1C,SAAS,EACT,QAAQ,OAAO,EAAE,EACjB,QAAQ,MAAM,EAAE;AAAA,YACzB;AACA,wBAAY,WAAW,MAAM;AAAA,UACjC;AAAA,QACJ,WAAW,QAAQ,qBAAqB,QAAQ,kBAAkB,QAAQ,GAAG,MAAM,IAAI;AACnF,gBAAM,yBAAyB,QAAQ,kBAAkB,MAAM,GAAG;AAClE,gBAAM,aAAa,aAAa,uBAAuB;AACvD,cAAI,YAAY;AACZ,wBAAY,WAAW,uBAAuB,IACzC,SAAS,EACT,QAAQ,OAAO,EAAE,EACjB,QAAQ,MAAM,EAAE;AAAA,UACzB;AAAA,QACJ,WAAW,QAAQ,qBAAqB,aAAa,QAAQ,oBAAoB;AAC7E,sBAAY,aAAa,QAAQ,mBAAmB,SAAS,EAAE,QAAQ,OAAO,EAAE;AAAA,QACpF;AAEA,YAAI,QAAQ,YAAY;AACpB,cAAI,QAAQ,wBAAwB,MAAM;AACtC,2BAAe;AAAA,UACnB;AAEA,kBAAQ,GAAG,QAAQ,kBAAkB,QAAQ,cAAc,KAAK,MAAM,KAAK;AAC3E,sBAAY,MAAM;AAAA,QACtB;AAEA,YACI,CAAC,QAAQ,cACT,OAAO,KAAK,YAAY,EAAE,WAAW,KACrC,OAAO,OAAO,KAAK,YAAY,EAAE,OAAO,YACxC,OAAO,OAAO,KAAK,YAAY,EAAE,OAAO,YACxC,OAAO,aAAa,OAAO,KAAK,YAAY,EAAE,QAAQ,YACtD,OAAO,aAAa,OAAO,KAAK,YAAY,EAAE,QAAQ,YACtD,aAAa,OAAO,KAAK,YAAY,EAAE,QAAQ,QACjD;AACE,cAAI,SAAS,aAAa,OAAO,KAAK,YAAY,EAAE;AACpD,cAAI,WAAW,aAAa,OAAO,KAAK,YAAY,EAAE;AAEtD,cACK,QAAQ,eAAe,KAAK,UAAU,QAAQ,KAC9C,QAAQ,oBAAoB,QAAQ,iBAAiB,SAAS,MAAM,GACvE;AACE,gBAAI;AACA,yBAAW,OAAO,KAAK,UAAU,QAAQ,EAAE,SAAS,MAAM;AAC1D,kBAAI,KAAK,cAAc,QAAQ,GAAG;AAC9B,2BAAW,mBAAAA,QAAQ,MAAM,QAAQ;AAAA,cACrC;AAAA,YACJ,SAAS,OAAP;AACE,mBAAK,QAAQ,IAAI;AAAA,gBACb,6BAA6B,gBAAgB,OAAO,MAAM,WAAW;AAAA,cACzE;AAAA,YACJ;AAAA,UACJ;AAEA,gBAAM,UAAU,OAAO,KAAK,YAAY,EAAE,KAAK,MAAM,OAAO,KAAK,YAAY,EAAE;AAC/E,cAAI,KAAK;AACL,qBAAS,MAAM,MAAM;AAAA,UACzB;AACA,cACI,CAAC,KAAK,sBAAsB,OAAO,MAAM,WACzC,KAAK,YAAY,OAAO,MAAM,YAAY,OAAO,UACnD;AACE,gBAAI,OAAO,aAAa,OAAO,OAAO,WAAW;AACjD,gBACI,KAAK,YAAY,OAAO,MAAM,WAC9B,KAAK,YAAY,OAAO,MAAM,YAAY,OAAO,UACnD;AACE,mBAAK,QAAQ,IAAI;AAAA,gBACb,WAAW,OAAO,MAAM,uBACpB,KAAK,YAAY,OAAO,MAAM,cAC3B,OAAO;AAAA,cAClB;AACA,qBAAO;AAAA,YACX;AACA,gBAAI;AACJ,gBAAI,QAAQ,UAAU,QAAQ,OAAO,SAAS;AAC1C,uBAAS,QAAQ,OAAO;AACxB,kBAAI,CAAC,OAAO,WAAW;AACnB,uBAAO,YAAY;AAAA,cACvB;AAAA,YACJ;AACA,kBAAM,SAAoB;AAAA,cACtB,MAAM;AAAA,cACN,MAAM,KAAK,SAAS,UAAU,QAAQ,SAAS,KAAK;AAAA,cACpD;AAAA,cACA,OAAO,QAAQ;AAAA,cACf,MAAM;AAAA,cACN;AAAA,YACJ;AACA,gBAAI,QAAQ,SAAS,QAAQ,MAAM,SAAS;AACxC,qBAAO,OAAO,QAAQ,MAAM;AAAA,YAChC;AACA,kBAAM,KAAK,aAAa,OAAO,MAAM,QAAQ,QAAQ,OAAO;AAAA,UAChE;AACA,gBAAM,KAAK,QAAQ,cAAc,OAAO,MAAM,QAAQ,UAAU,IAAI;AACpE;AAAA,QACJ;AACA,cAAM,KAAK,MAAM,OAAO,MAAM,WAAW,cAAc,OAAO;AAAA,MAClE;AAAA,IACJ,SAAS,OAAP;AACE,WAAK,QAAQ,IAAI,MAAM,0BAA0B,IAAI;AACrD,WAAK,QAAQ,IAAI,MAAM,KAAK;AAAA,IAChC;AAAA,EACJ;AAAA,EAOA,UAAU,KAAsB;AAC5B,QAAI,CAAC,OAAO,OAAO,QAAQ,UAAU;AACjC,aAAO;AAAA,IACX;AACA,UAAM,cAAc;AACpB,WAAO,YAAY,KAAK,GAAG;AAAA,EAC/B;AAAA,EAOA,cAAc,KAAsB;AAChC,QAAI;AACA,WAAK,MAAM,GAAG;AAAA,IAClB,SAAS,GAAP;AACE,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAOA,SAAS,SAAc,OAAwB;AAC3C,QAAI,OAAO,YAAY,aAAa,CAAC,OAAO;AACxC,aAAO;AAAA,IACX;AACA,QAAI,OAAO,YAAY,aAAa,OAAO;AACvC,aAAO;AAAA,IACX;AACA,QAAI,OAAO,YAAY,YAAY,CAAC,OAAO;AACvC,UAAI,WAAW,QAAQ,SAAS,EAAE,WAAW,IAAI;AAC7C,YAAI,UAAU,SAAiB,UAAU,MAAe;AACpD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,QAAI,OAAO,YAAY,YAAY,OAAO;AACtC,aAAO;AAAA,IACX;AACA,QAAI,OAAO,YAAY,UAAU;AAC7B,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ;AACA,iBAAS;",
  "names": ["JSONbig"]
}
